# widget_setup.py (Sets up ipywidgets for interactive plotting in Jupyter)
import pandas as pd
import ipywidgets as widgets
from ipywidgets import VBox, HBox, Layout, Output # Import Output widget
from IPython.display import display, clear_output, Image # Added Image for displaying saved plots
import logging
import numpy as np
from typing import Dict, Any, List, Tuple, Optional, Union
import torch # Optional, only if device selection is needed here
import os
import json # For loading evaluation results
import matplotlib.pyplot as plt # For plotting

# Import joblib load safely (for R-peak data)
try:
    from joblib import load
except ImportError:
    load = None
    logging.warning("joblib not found. Loading R-peak data for plotting will fail.")

# Import plotting and utility functions from other modules
try:
    from visualization import (
        plot_raw_signal, plot_ecg_with_peaks, plot_raw_vs_resampled,
        get_available_signals, plot_predictions_on_signal, plot_training_history
        # ROC/PR plots are usually generated by evaluation.py, but could be called here if needed
    )
    from utils import safe_get, get_sampling_rate
except ImportError:
    # Define dummy fallbacks if imports fail
    def plot_raw_signal(*args, **kwargs): print("Plotting function 'plot_raw_signal' unavailable.")
    def plot_ecg_with_peaks(*args, **kwargs): print("Plotting function 'plot_ecg_with_peaks' unavailable.")
    def plot_raw_vs_resampled(*args, **kwargs): print("Plotting function 'plot_raw_vs_resampled' unavailable.")
    def get_available_signals(*args, **kwargs): print("Util function 'get_available_signals' unavailable."); return []
    def plot_predictions_on_signal(*args, **kwargs): print("Plotting function 'plot_predictions_on_signal' unavailable.")
    def plot_training_history(*args, **kwargs): print("Plotting function 'plot_training_history' unavailable.")
    def safe_get(data_dict, keys, default=None): temp=data_dict; [temp := temp.get(i,{}) if isinstance(temp,dict) else default for i in keys]; return temp if temp else default
    def get_sampling_rate(*args): return None
    logging.error("Could not import from 'visualization' or 'utils'. Interactive plotting will likely fail.")

log = logging.getLogger(__name__)

# --- Constants ---
# Default duration for the time slider window
SLIDING_WINDOW_DURATION_S = 60

# --- Helper to estimate max signal time for sliders ---
def _get_max_time(
    subject_id: Union[int, str],
    data_dict: Dict[Union[int, str], Dict[str, Any]], # Can be raw or processed data
    config: Dict[str, Any],
    signal_priority: List[str] = ['label', 'ECG', 'ACC', 'BVP', 'EDA', 'TEMP', 'RESP'] # Prioritize label or longest signals
) -> int:
    """
    Estimates the maximum possible start time for the time slider based on signal lengths
    within the provided data dictionary (raw or processed).

    Args:
        subject_id (Union[int, str]): The subject ID.
        data_dict (Dict): The dictionary containing data for the subject.
        config (Dict): Configuration dictionary for fallback rates and max duration.
        signal_priority (List[str]): Order in which to check signals for length/rate.

    Returns:
        int: The maximum value for the time slider's start position (in seconds).
    """
    # Max duration allowed from config, fallback to 10 minutes (600s)
    max_time_limit_secs_config = safe_get(config, ['visualization', 'max_plot_duration_s'], 600)
    # Minimum duration of the plot window itself
    default_min_duration = SLIDING_WINDOW_DURATION_S
    calculated_max_secs = 0 # Default if no data found

    # Check if subject exists in the provided data dictionary
    if not data_dict or subject_id not in data_dict:
        log.warning(f"_get_max_time: Subject {subject_id} not found in provided data_dict.")
        # Return a default max value based on config, ensuring it's non-negative
        return max(0, max_time_limit_secs_config - default_min_duration)

    subj_data = data_dict[subject_id]
    max_len = 0 # Track max length found
    est_fs = None # Estimated sampling rate corresponding to max_len

    # Iterate through prioritized signals to find the longest one with a known rate
    for sig_key in signal_priority:
        signal = None
        fs = None
        source = None # Keep track of source for rate lookup if needed

        if sig_key == 'label':
            signal = safe_get(subj_data, ['label'])
            # Check for final (processed) rate first, then original
            fs = safe_get(subj_data, ['sampling_rates', 'label_final'])
            if fs is None: # Fallback to original rate lookup if final rate not found
                dataset_id = subj_data.get('dataset_id', 'WESAD') # Need dataset ID
                fs = get_sampling_rate(config, 'label', 'label', dataset_id=dataset_id)
        else:
            # Check both chest and wrist sources for the signal
            for device in ['chest', 'wrist']:
                candidate_signal = safe_get(subj_data, ['signal', device, sig_key])
                if candidate_signal is not None:
                    signal = candidate_signal
                    # Check for final (processed) rate first
                    fs = safe_get(subj_data, ['sampling_rates', f"{sig_key}_final"])
                    if fs is None: # Fallback to original rate lookup
                         dataset_id = subj_data.get('dataset_id', 'WESAD')
                         fs = get_sampling_rate(config, sig_key, device, dataset_id=dataset_id)
                    source = device
                    break # Found signal in this source

        # If signal and valid rate found, check length
        if signal is not None and hasattr(signal, 'shape') and fs is not None and fs > 0:
            current_len = signal.shape[0]
            if current_len > max_len:
                max_len = current_len
                est_fs = fs # Store the rate corresponding to the longest signal found so far

    # Calculate max duration in seconds based on longest signal
    if max_len > 0 and est_fs is not None and est_fs > 0:
        calculated_max_secs = int(max_len / est_fs)
    else:
        log.warning(f"_get_max_time: Could not determine length/Fs for S{subject_id}. Using config max duration ({max_time_limit_secs_config}s).")
        calculated_max_secs = max_time_limit_secs_config # Fallback to config max

    # Calculate the max value for the *start* time slider
    # Max start time = Total duration - Window duration
    final_max_slider_start = max(0, calculated_max_secs - SLIDING_WINDOW_DURATION_S)
    # Also limit by the overall max duration specified in config
    max_slider_limit = max(0, max_time_limit_secs_config - SLIDING_WINDOW_DURATION_S)
    final_max_slider_start = min(final_max_slider_start, max_slider_limit)

    return max(0, final_max_slider_start) # Ensure slider max value is non-negative


# ==============================================================================
# == Interactive Plotter Setup Functions ==
# ==============================================================================

# --- Raw Signal Plotter Setup ---
def setup_raw_signal_plotter(config: Dict, all_subject_data: Dict, subjects_loaded: List[Union[int, str]]):
    """
    Sets up ipywidgets for interactively plotting raw signals.

    Args:
        config (Dict): Configuration dictionary.
        all_subject_data (Dict): Dictionary containing the raw data for all subjects.
        subjects_loaded (List[Union[int, str]]): List of subject IDs that were loaded.
    """
    log.info("Setting up interactive raw signal plotter...")
    # Validate inputs
    if not all_subject_data or not subjects_loaded:
        log.error("Cannot set up raw plotter: Raw data dictionary or loaded subjects list is missing.")
        print("ERROR: Raw data or subjects list missing for plotter setup.")
        return

    # --- Create Widgets ---
    plot_output_raw = Output() # Output widget to display the plot
    # Subject Dropdown: Use string versions of IDs for display
    subject_options_raw_str = sorted([str(s) for s in subjects_loaded if s in all_subject_data])
    if not subject_options_raw_str:
        print("ERROR: No subjects with raw data available for plotting.")
        return
    subject_dd_raw = widgets.Dropdown(
        options=subject_options_raw_str,
        value=subject_options_raw_str[0], # Default to first subject
        description='Subject (Raw):',
        style={'description_width': 'initial'}
    )

    # Helper to map dropdown string back to original ID (int or string like "NURSE_1")
    def get_orig_id(selected_str):
        try: return subjects_loaded[subject_options_raw_str.index(selected_str)]
        except (ValueError, IndexError): return None

    # Signal Dropdown: Options updated dynamically based on selected subject
    default_subj_id_orig = get_orig_id(subject_dd_raw.value)
    available_signals_raw = get_available_signals(all_subject_data[default_subj_id_orig], config) if default_subj_id_orig else []
    signal_dd_raw = widgets.Dropdown(
        options=available_signals_raw,
        value=available_signals_raw[0] if available_signals_raw else None,
        description='Signal:',
        style={'description_width': 'initial'},
        disabled=not available_signals_raw # Disable if no signals available
    )

    # Time Slider: Range updated dynamically based on selected subject
    max_start_time_raw = _get_max_time(default_subj_id_orig, all_subject_data, config) if default_subj_id_orig else 0
    time_slider_raw = widgets.IntSlider(
        value=0, min=0, max=max_start_time_raw, step=1,
        description=f'Start Time ({SLIDING_WINDOW_DURATION_S}s window):',
        continuous_update=False, # Update plot only when slider released
        layout=Layout(width='80%'),
        style={'description_width': 'initial'}
    )

    # --- Define Callbacks ---
    # Callback to update signal options and slider range when subject changes
    def _update_raw_signals_options(change):
        selected_subject_str = change['new']
        selected_subject_orig = get_orig_id(selected_subject_str)
        with plot_output_raw: # Use the output widget context
            clear_output(wait=True) # Clear previous plot/messages
            if selected_subject_orig and selected_subject_orig in all_subject_data:
                # Get available signals for the new subject
                new_available_signals = get_available_signals(all_subject_data[selected_subject_orig], config)
                signal_dd_raw.options = new_available_signals
                signal_dd_raw.disabled = not new_available_signals
                # Update signal dropdown value (keep current if possible, else default)
                if new_available_signals:
                    current_signal = signal_dd_raw.value
                    signal_dd_raw.value = current_signal if current_signal in new_available_signals else new_available_signals[0]
                else:
                    signal_dd_raw.value = None
                # Update time slider max value
                new_max_start_time = _get_max_time(selected_subject_orig, all_subject_data, config)
                # Temporarily unobserve slider to prevent triggering plot during update
                time_slider_raw.unobserve(_trigger_raw_plot, names='value')
                time_slider_raw.max = new_max_start_time
                # Reset slider value if current value exceeds new max
                if time_slider_raw.value > new_max_start_time: time_slider_raw.value = 0
                # Re-observe slider and trigger initial plot for new subject
                time_slider_raw.observe(_trigger_raw_plot, names='value')
                _trigger_raw_plot({}) # Trigger plot update
            else:
                # Handle case where selected subject data is missing
                signal_dd_raw.options = []
                signal_dd_raw.value = None
                signal_dd_raw.disabled = True
                time_slider_raw.max = 0
                time_slider_raw.value = 0
                print(f"Raw data for subject {selected_subject_str} not found.")

    # Callback to trigger plotting when any control changes value
    def _trigger_raw_plot(change): # 'change' argument is needed for observe callback
         with plot_output_raw: # Use the output widget context
             clear_output(wait=True) # Clear previous plot
             # Get current values from widgets
             subj_id_str = subject_dd_raw.value
             sig_key = signal_dd_raw.value
             start_time_s = time_slider_raw.value
             end_time_s = start_time_s + SLIDING_WINDOW_DURATION_S
             time_range = (start_time_s, end_time_s)
             subj_id_orig = get_orig_id(subj_id_str)

             # Check if selections are valid before plotting
             if subj_id_orig and sig_key and subj_id_orig in all_subject_data:
                 print(f"Plotting Raw S{subj_id_orig}, Signal: {sig_key}, Time: {start_time_s:.1f}s - {end_time_s:.1f}s")
                 try:
                     # Call the plotting function from visualization module
                     # Pass plt.gca() to plot on the current axes within the Output widget
                     plot_raw_signal(
                         subject_data=all_subject_data[subj_id_orig],
                         config=config,
                         subject_id=subj_id_orig,
                         signal_key=sig_key,
                         time_range_sec=time_range,
                         ax=plt.gca() # Get current axes
                     )
                     plt.show() # Explicitly show the plot in the output widget
                 except Exception as e:
                     log.error(f"Error plotting raw S{subj_id_orig}, {sig_key}: {e}", exc_info=True)
                     print(f"An error occurred during plotting: {e}")
             elif subj_id_orig and not sig_key:
                 print(f"Please select a signal for subject {subj_id_orig}.")
             else:
                 print("Please select a subject and signal.")

    # --- Link Callbacks to Widgets ---
    subject_dd_raw.observe(_update_raw_signals_options, names='value') # Update signals/slider on subject change
    signal_dd_raw.observe(_trigger_raw_plot, names='value') # Trigger plot on signal change
    time_slider_raw.observe(_trigger_raw_plot, names='value') # Trigger plot on slider change

    # --- Display Widgets ---
    controls_raw = VBox([HBox([subject_dd_raw, signal_dd_raw]), time_slider_raw])
    display(controls_raw, plot_output_raw) # Display controls and output area
    _trigger_raw_plot({}) # Trigger initial plot load

    log.info("Interactive raw signal plotter setup complete.")


# --- Raw vs Resampled Comparison Plotter Setup ---
def setup_comparison_plotter(config: Dict, all_subject_data: Dict, processed_data: Dict, subjects_loaded: List[Union[int, str]]):
    """
    Sets up ipywidgets for interactively comparing raw vs. resampled signals.

    Args:
        config (Dict): Configuration dictionary.
        all_subject_data (Dict): Dictionary containing the raw data.
        processed_data (Dict): Dictionary containing the processed (resampled) data.
        subjects_loaded (List[Union[int, str]]): List of subject IDs that were loaded.
    """
    log.info("Setting up interactive raw vs. resampled comparison plotter...")
    # Validate inputs
    if not all_subject_data or not processed_data or not subjects_loaded:
        log.error("Cannot set up comparison plotter: Raw, processed data, or subjects list missing.")
        print("ERROR: Data missing for comparison plotter setup.")
        return

    # --- Create Widgets ---
    plot_output_comp = Output()
    # Find subjects present in BOTH raw and processed data
    valid_subjects_orig = [s for s in subjects_loaded if s in all_subject_data and s in processed_data]
    valid_subjects_str = sorted([str(s) for s in valid_subjects_orig])
    if not valid_subjects_str:
        print("ERROR: No subjects found with both raw and processed data for comparison.")
        return

    subject_dd_comp = widgets.Dropdown(
        options=valid_subjects_str,
        value=valid_subjects_str[0],
        description='Subject (Comp):',
        style={'description_width': 'initial'}
    )

    # Helper to map dropdown string back to original ID
    def get_orig_id_comp(selected_str):
        try: return valid_subjects_orig[valid_subjects_str.index(selected_str)]
        except (ValueError, IndexError): return None

    default_subj_id_orig = get_orig_id_comp(subject_dd_comp.value)
    # Get available signals from processed data (should be same as raw after filtering)
    available_signals_comp = get_available_signals(processed_data[default_subj_id_orig], config) if default_subj_id_orig in processed_data else []
    signal_dd_comp = widgets.Dropdown(
        options=available_signals_comp,
        value=available_signals_comp[0] if available_signals_comp else None,
        description='Signal:',
        style={'description_width': 'initial'},
        disabled=not available_signals_comp
    )

    # Use processed data to determine max time (as it defines the aligned length)
    max_start_time_comp = _get_max_time(default_subj_id_orig, processed_data, config) if default_subj_id_orig in processed_data else 0
    time_slider_comp = widgets.IntSlider(
        value=0, min=0, max=max_start_time_comp, step=1,
        description=f'Start Time ({SLIDING_WINDOW_DURATION_S}s window):',
        continuous_update=False,
        layout=Layout(width='80%'),
        style={'description_width': 'initial'}
    )

    # --- Define Callbacks ---
    def _update_comp_signals_options(change):
        selected_subject_str = change['new']
        selected_subject_orig = get_orig_id_comp(selected_subject_str)
        with plot_output_comp:
            clear_output(wait=True)
            if selected_subject_orig and selected_subject_orig in processed_data and selected_subject_orig in all_subject_data:
                new_available_signals = get_available_signals(processed_data[selected_subject_orig], config)
                signal_dd_comp.options = new_available_signals
                signal_dd_comp.disabled = not new_available_signals
                if new_available_signals:
                    current_signal = signal_dd_comp.value
                    signal_dd_comp.value = current_signal if current_signal in new_available_signals else new_available_signals[0]
                else:
                    signal_dd_comp.value = None
                new_max_start_time = _get_max_time(selected_subject_orig, processed_data, config)
                time_slider_comp.unobserve(_trigger_comp_plot, names='value')
                time_slider_comp.max = new_max_start_time
                if time_slider_comp.value > new_max_start_time: time_slider_comp.value = 0
                time_slider_comp.observe(_trigger_comp_plot, names='value')
                _trigger_comp_plot({})
            else:
                signal_dd_comp.options = []
                signal_dd_comp.value = None
                signal_dd_comp.disabled = True
                time_slider_comp.max = 0
                time_slider_comp.value = 0
                print(f"Raw or processed data missing for S{selected_subject_str} comparison.")

    def _trigger_comp_plot(change):
        with plot_output_comp:
            clear_output(wait=True)
            subj_id_str = subject_dd_comp.value
            sig_key = signal_dd_comp.value
            start_time_s = time_slider_comp.value
            end_time_s = start_time_s + SLIDING_WINDOW_DURATION_S
            time_range = (start_time_s, end_time_s)
            subj_id_orig = get_orig_id_comp(subj_id_str)

            if subj_id_orig and sig_key and subj_id_orig in all_subject_data and subj_id_orig in processed_data:
                print(f"Plotting Comparison S{subj_id_orig}, Signal: {sig_key}, Time: {start_time_s:.1f}s - {end_time_s:.1f}s")
                try:
                    # Call the comparison plotting function
                    plot_raw_vs_resampled(
                        subject_id=subj_id_orig,
                        signal_key=sig_key,
                        time_range_sec=time_range,
                        raw_subject_data=all_subject_data[subj_id_orig],
                        processed_subject_data=processed_data[subj_id_orig],
                        config=config
                    )
                    # No plt.show() needed here as plot_raw_vs_resampled handles figure creation and showing
                except Exception as e:
                    log.error(f"Error plotting comparison S{subj_id_orig}, {sig_key}: {e}", exc_info=True)
                    print(f"An error occurred during comparison plotting: {e}")
            elif subj_id_orig and not sig_key:
                print(f"Please select a signal for subject {subj_id_orig}.")
            else:
                print("Please select a subject and signal.")

    # --- Link Callbacks ---
    subject_dd_comp.observe(_update_comp_signals_options, names='value')
    signal_dd_comp.observe(_trigger_comp_plot, names='value')
    time_slider_comp.observe(_trigger_comp_plot, names='value')

    # --- Display Widgets ---
    controls_comp = VBox([HBox([subject_dd_comp, signal_dd_comp]), time_slider_comp])
    display(controls_comp, plot_output_comp)
    _trigger_comp_plot({}) # Initial plot

    log.info("Interactive comparison plotter setup complete.")


# --- ECG + R-Peaks + Labels Plotter Setup ---
def setup_hrv_plotter(config: Dict, processed_data: Dict, r_peak_results: Optional[Dict[Union[int, str], Optional[np.ndarray]]] = None):
    """
    Sets up ipywidgets for interactively plotting ECG signal with R-peaks and true labels.
    Attempts to load R-peak data if not provided.

    Args:
        config (Dict): Configuration dictionary.
        processed_data (Dict): Dictionary containing the processed data.
        r_peak_results (Optional[Dict]): Dictionary containing R-peak indices. If None, attempts to load from file.
    """
    log.info("Setting up interactive ECG+Peaks+Labels plotter...")
    plot_output_hrv = Output()

    # --- Load R-peak data if not provided ---
    if r_peak_results is None:
        log.info("R-peak results not provided, attempting to load from file...")
        if load is None: # Check if joblib is available
            log.error("joblib not installed. Cannot load R-peak indices.")
            r_peak_results = {} # Use empty dict if loading fails
        else:
             r_peak_dir = safe_get(config, ['save_paths', 'static_features_results']) # R-peaks saved with static features
             if r_peak_dir and isinstance(r_peak_dir, str):
                  rpeak_load_path = os.path.join(os.path.abspath(r_peak_dir), "r_peak_indices.joblib")
                  if os.path.exists(rpeak_load_path):
                       try:
                           r_peak_results = load(rpeak_load_path)
                           log.info(f"Successfully loaded R-peak indices from {rpeak_load_path}")
                       except Exception as e:
                           log.error(f"Failed to load R-peak indices from {rpeak_load_path}: {e}")
                           r_peak_results = {}
                  else:
                       log.warning(f"R-peak indices file not found at {rpeak_load_path}. Cannot plot R-peaks.")
                       r_peak_results = {}
             else:
                 log.warning("Path for R-peak indices ('save_paths.static_features_results') not configured. Cannot load/plot R-peaks.")
                 r_peak_results = {}
    if r_peak_results is None: r_peak_results = {} # Ensure it's a dict

    # --- Find subjects with necessary data (ECG, Label, Rate) ---
    subjects_with_ecg_data_orig = []
    for s_id, proc_data in processed_data.items():
         # Check for ECG signal, labels, and the final ECG sampling rate
         if (safe_get(proc_data, ['signal', 'chest', 'ECG']) is not None and
             safe_get(proc_data, ['label']) is not None and
             safe_get(proc_data, ['sampling_rates', 'ECG_final']) is not None):
             subjects_with_ecg_data_orig.append(s_id)

    subjects_with_ecg_data_str = sorted([str(s) for s in subjects_with_ecg_data_orig])
    if not subjects_with_ecg_data_str:
        log.error("No valid subjects available for ECG+Peaks+Labels plotter (missing ECG, labels, or Fs).")
        print("ERROR: No subjects found with required ECG, labels, and sampling rate.")
        return

    # --- Create Widgets ---
    subject_dd_hrv = widgets.Dropdown(
        options=subjects_with_ecg_data_str,
        value=subjects_with_ecg_data_str[0],
        description='Subject (ECG):',
        style={'description_width': 'initial'}
    )

    # Helper to map dropdown string back to original ID
    def get_orig_id_hrv(selected_str):
        try: return subjects_with_ecg_data_orig[subjects_with_ecg_data_str.index(selected_str)]
        except (ValueError, IndexError): return None

    default_subj_id_orig = get_orig_id_hrv(subject_dd_hrv.value)
    # Use ECG or label signal to determine max time
    max_start_time_hrv = _get_max_time(default_subj_id_orig, processed_data, config, signal_priority=['ECG', 'label']) if default_subj_id_orig else 0
    time_slider_hrv = widgets.IntSlider(
        value=0, min=0, max=max_start_time_hrv, step=1,
        description=f'Start Time ({SLIDING_WINDOW_DURATION_S}s window):',
        continuous_update=False,
        layout=Layout(width='80%'),
        style={'description_width': 'initial'}
    )

    # --- Define Callbacks ---
    def _update_hrv_slider_options(change):
        selected_subject_str = change['new']
        selected_subject_orig = get_orig_id_hrv(selected_subject_str)
        with plot_output_hrv:
            clear_output(wait=True)
            if selected_subject_orig and selected_subject_orig in processed_data:
                new_max_start_time = _get_max_time(selected_subject_orig, processed_data, config, signal_priority=['ECG', 'label'])
                time_slider_hrv.unobserve(_trigger_hrv_plot, names='value')
                time_slider_hrv.max = new_max_start_time
                if time_slider_hrv.value > new_max_start_time: time_slider_hrv.value = 0
                time_slider_hrv.observe(_trigger_hrv_plot, names='value')
                _trigger_hrv_plot({}) # Trigger plot update for new subject
            else:
                time_slider_hrv.max = 0
                time_slider_hrv.value = 0
                print(f"Processed data missing for S{selected_subject_str}.")

    def _trigger_hrv_plot(change):
        with plot_output_hrv:
            clear_output(wait=True)
            subj_id_str = subject_dd_hrv.value
            start_time_s = time_slider_hrv.value
            end_time_s = start_time_s + SLIDING_WINDOW_DURATION_S
            time_range = (start_time_s, end_time_s)
            subj_id_orig = get_orig_id_hrv(subj_id_str)

            if subj_id_orig and subj_id_orig in processed_data:
                print(f"Plotting ECG+Peaks+Labels S{subj_id_orig}, Time: {start_time_s:.1f}s - {end_time_s:.1f}s")
                # Retrieve necessary data components
                ecg_sig = safe_get(processed_data[subj_id_orig], ['signal', 'chest', 'ECG'])
                true_labels = safe_get(processed_data[subj_id_orig], ['label'])
                ecg_fs = safe_get(processed_data[subj_id_orig], ['sampling_rates', 'ECG_final'])
                r_peaks = r_peak_results.get(subj_id_orig, None) # Get peaks for the original ID

                if r_peaks is None:
                    log.warning(f"No R-peaks found for S{subj_id_orig} in loaded r_peak_results.")
                    print(f"Warning: R-peak data not found for S{subj_id_orig}. Peaks will not be plotted.")

                try:
                    # Call the plotting function
                    plot_ecg_with_peaks(
                        ecg_signal=ecg_sig,
                        r_peak_indices=r_peaks,
                        true_labels=true_labels,
                        sampling_rate=ecg_fs,
                        subject_id=subj_id_orig,
                        time_range_sec=time_range,
                        ax=plt.gca() # Use current axes
                    )
                    plt.show() # Show plot in output
                except Exception as e:
                    log.error(f"Error during ECG+Peaks+Labels plotting for S{subj_id_orig}: {e}", exc_info=True)
                    print(f"An error occurred during plotting: {e}")
            else:
                print("Please select a valid subject with processed ECG data.")

    # --- Link Callbacks ---
    subject_dd_hrv.observe(_update_hrv_slider_options, names='value')
    time_slider_hrv.observe(_trigger_hrv_plot, names='value')

    # --- Display Widgets ---
    controls_hrv = VBox([subject_dd_hrv, time_slider_hrv])
    display(controls_hrv, plot_output_hrv)
    _trigger_hrv_plot({}) # Initial plot

    log.info("Interactive ECG+Peaks+Labels plotter setup complete.")


# --- Prediction Plotter Setup ---
def setup_prediction_plotter(
    config: Dict,
    processed_data: Dict[Union[int, str], Dict[str, Any]],
    # Dictionary mapping subject ID to a tuple: (list_of_window_start_samples, list_of_window_predictions)
    all_predictions: Dict[Union[int, str], Tuple[List[int], List[int]]],
    device: Optional[torch.device] = None # Optional device arg (unused currently)
    ):
    """
    Sets up ipywidgets for interactively plotting predictions overlaid on a signal.

    Args:
        config (Dict): Configuration dictionary.
        processed_data (Dict): Dictionary containing processed data for subjects.
        all_predictions (Dict): Dictionary mapping subject IDs to their prediction results
                                (window start samples and corresponding predictions).
        device (Optional[torch.device], optional): Device (unused in this function). Defaults to None.
    """
    log.info("Setting up interactive prediction plotter...")
    # Validate inputs
    if not processed_data:
        print("ERROR: Processed data missing for prediction plotter setup.")
        return
    if not all_predictions:
        print("ERROR: Pre-computed predictions dictionary missing for plotter setup.")
        return

    # --- Create Widgets ---
    plot_output_pred = Output()
    # Find subjects present in BOTH processed data and predictions
    potential_subjects_orig = sorted([s for s in processed_data.keys() if s in all_predictions])
    potential_subjects_str = sorted([str(s) for s in potential_subjects_orig])
    if not potential_subjects_str:
        print("ERROR: No subjects found with both processed data and predictions.")
        return

    default_subj_id_str = potential_subjects_str[0]
    subject_dd_pred = widgets.Dropdown(
        options=potential_subjects_str,
        value=default_subj_id_str,
        description='Subject (Pred):',
        style={'description_width': 'initial'}
    )

    # Helper to map dropdown string back to original ID
    def get_orig_id_pred(selected_str):
        try: return potential_subjects_orig[potential_subjects_str.index(selected_str)]
        except (ValueError, IndexError): return None

    default_subj_id_orig = get_orig_id_pred(default_subj_id_str)
    # Get available signals from processed data
    available_signals_pred = get_available_signals(processed_data[default_subj_id_orig], config) if default_subj_id_orig else []
    signal_dd_pred = widgets.Dropdown(
        options=available_signals_pred,
        value=available_signals_pred[0] if available_signals_pred else None,
        description='Signal:',
        style={'description_width': 'initial'},
        disabled=not available_signals_pred
    )

    max_start_time_pred = _get_max_time(default_subj_id_orig, processed_data, config) if default_subj_id_orig else 0
    time_slider_pred = widgets.IntSlider(
        value=0, min=0, max=max_start_time_pred, step=1,
        description=f'Start Time ({SLIDING_WINDOW_DURATION_S}s window):',
        continuous_update=False,
        layout=Layout(width='80%'),
        style={'description_width': 'initial'}
    )

    # --- Define Callbacks ---
    def _update_pred_signals_options(change):
        selected_subject_str = change['new']
        selected_subject_orig = get_orig_id_pred(selected_subject_str)
        with plot_output_pred:
            clear_output(wait=True)
            if selected_subject_orig and selected_subject_orig in processed_data:
                new_available_signals = get_available_signals(processed_data[selected_subject_orig], config)
                signal_dd_pred.options = new_available_signals
                signal_dd_pred.disabled = not new_available_signals
                if new_available_signals:
                    current_signal = signal_dd_pred.value
                    signal_dd_pred.value = current_signal if current_signal in new_available_signals else new_available_signals[0]
                else:
                    signal_dd_pred.value = None
                new_max_start_time = _get_max_time(selected_subject_orig, processed_data, config)
                time_slider_pred.unobserve(_trigger_pred_plot, names='value')
                time_slider_pred.max = new_max_start_time
                if time_slider_pred.value > new_max_start_time: time_slider_pred.value = 0
                time_slider_pred.observe(_trigger_pred_plot, names='value')
                _trigger_pred_plot({})
            else:
                # Handle case where processed data is missing for the selected subject
                signal_dd_pred.options = []
                signal_dd_pred.value = None
                signal_dd_pred.disabled = True
                time_slider_pred.max = 0
                time_slider_pred.value = 0
                print(f"Processed data for subject {selected_subject_str} not found.")

    def _trigger_pred_plot(change):
        with plot_output_pred:
            clear_output(wait=True)
            subj_id_str = subject_dd_pred.value
            sig_key = signal_dd_pred.value
            start_time_s = time_slider_pred.value
            end_time_s = start_time_s + SLIDING_WINDOW_DURATION_S
            time_range = (start_time_s, end_time_s)
            subj_id_orig = get_orig_id_pred(subj_id_str)

            # Check if all necessary data is available
            if subj_id_orig and sig_key and subj_id_orig in processed_data and subj_id_orig in all_predictions:
                print(f"Plotting Predictions S{subj_id_orig}, Signal: {sig_key}, Time: {start_time_s:.1f}s - {end_time_s:.1f}s")
                # Get prediction data for the subject
                window_starts, window_preds = all_predictions[subj_id_orig]
                if not window_starts:
                    print(f"Warning: No prediction window start times found for S{subj_id_orig}.")
                if not window_preds:
                     print(f"Warning: No prediction values found for S{subj_id_orig}.")

                try:
                    # Call the plotting function
                    plot_predictions_on_signal(
                        processed_data=processed_data,
                        config=config,
                        subject_id=subj_id_orig,
                        signal_key=sig_key,
                        time_range_sec=time_range,
                        window_start_samples=window_starts,
                        window_predictions=window_preds,
                        ax=plt.gca() # Use current axes
                    )
                    plt.show()
                except Exception as e:
                    log.error(f"Error plotting predictions S{subj_id_orig}, {sig_key}: {e}", exc_info=True)
                    print(f"An error occurred during prediction plotting: {e}")
            elif subj_id_orig and not sig_key:
                print(f"Please select a signal for subject {subj_id_orig}.")
            elif subj_id_orig not in all_predictions:
                print(f"Prediction results not available for S{subj_id_orig}.")
            else:
                print("Please select a subject and signal.")

    # --- Link Callbacks ---
    subject_dd_pred.observe(_update_pred_signals_options, names='value')
    signal_dd_pred.observe(_trigger_pred_plot, names='value')
    time_slider_pred.observe(_trigger_pred_plot, names='value')

    # --- Display Widgets ---
    controls_pred = VBox([HBox([subject_dd_pred, signal_dd_pred]), time_slider_pred])
    display(controls_pred, plot_output_pred)
    _trigger_pred_plot({}) # Initial plot

    log.info("Interactive prediction plotter setup complete.")


# --- Display Evaluation Results and Plots ---
def display_evaluation_results(config: Dict, results_file_path: Optional[str] = None):
    """
    Displays evaluation metrics from a JSON file and shows associated plots
    (Training History, Confusion Matrix, ROC, PR, SHAP) found in the results directory.

    Args:
        config (Dict): Configuration dictionary to find the results directory.
        results_file_path (Optional[str]): Path to the specific evaluation JSON file.
                                           If None, defaults to 'test_evaluation_results.json'
                                           in the configured results directory.
    """
    log.info("Setting up evaluation results display...")
    output_display = Output() # Create an output widget
    display(output_display) # Display it in the notebook

    with output_display: # Capture output within this widget
        clear_output(wait=True)
        print("--- Loading and Displaying Evaluation Results ---")

        # --- Determine Results Directory and File Path ---
        results_dir = safe_get(config, ['save_paths', 'results'], './outputs/results') # Default path
        # Use provided path or construct default path
        if results_file_path is None:
            results_file_path = os.path.join(results_dir, "test_evaluation_results.json")
        else:
            # If a specific path is given, ensure the directory exists for plot lookup
            results_dir = os.path.dirname(results_file_path)

        # Check if the results JSON file exists
        if not os.path.exists(results_file_path):
            print(f"\nERROR: Evaluation results file not found at {results_file_path}")
            log.error(f"Evaluation results file not found at {results_file_path}")
            return

        # --- Load and Display Metrics from JSON ---
        results_data = {} # Initialize empty dict
        try:
            with open(results_file_path, 'r') as f:
                results_data = json.load(f) # Load metrics
            print("\n--- Evaluation Metrics ---")
            # Nicely format and print the metrics
            for key, value in results_data.items():
                if key == 'classification_report':
                    print(f"\nClassification Report:\n{value}")
                elif key == 'confusion_matrix':
                    # Print confusion matrix using numpy for better formatting
                    try: cm_array = np.array(value); print(f"\nConfusion Matrix (Rows: True, Cols: Pred):\n{cm_array}")
                    except: print(f"\nConfusion Matrix:\n{value}") # Fallback if conversion fails
                elif key not in ['probabilities', 'labels']: # Avoid printing large lists of probs/labels
                    # Format floats nicely
                    print(f"{key.replace('_', ' ').title()}: {value:.4f}" if isinstance(value, float) else f"{key.replace('_', ' ').title()}: {value}")
            print("-" * 26)
        except Exception as e:
            print(f"\nERROR: Failed to load or display metrics from {results_file_path}: {e}")
            log.error(f"Failed to load/display metrics from {results_file_path}: {e}", exc_info=True)
            # Continue to try and display plots even if metrics fail

        # --- Display Associated Plots ---
        print("\n--- Evaluation Plots ---")
        # Define expected filenames based on conventions used in evaluation.py and visualization.py
        # Get the threshold used from the loaded results if available
        threshold_used = results_data.get('threshold_used', 0.5) # Default to 0.5 if not found
        plot_files_to_check = {
            "Training History": "training_history.png",
            # Assume plots saved by evaluation.py use 'test' in filename
            "Confusion Matrix": f"confusion_matrix_test_thresh{threshold_used:.2f}.png",
            "ROC Curve": "roc_curve_test.png",
            "Precision-Recall Curve": "precision_recall_curve_test.png",
            "SHAP Summary": "shap_summary_plot.png" # Assumes SHAP plot is saved with this name
        }

        found_any_plot = False
        # Look for each plot file in the results directory
        for plot_name, filename in plot_files_to_check.items():
            plot_path = os.path.join(results_dir, filename) # Construct full path
            if os.path.exists(plot_path):
                try:
                    print(f"\nDisplaying {plot_name}:")
                    # Use IPython.display.Image to show the plot file
                    display(Image(filename=plot_path))
                    found_any_plot = True
                except Exception as e:
                    print(f"ERROR: Could not display {plot_name} from {plot_path}: {e}")
                    log.error(f"Could not display {plot_name} from {plot_path}: {e}", exc_info=True)
            else:
                # File not found message
                print(f"\n* {plot_name} plot not found at: {plot_path}")
                log.warning(f"{plot_name} plot not found at: {plot_path}")

        if not found_any_plot:
            print("\nNo evaluation plot files found in the results directory.")

    log.info("Evaluation results display setup complete.")
